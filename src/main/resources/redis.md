因为压缩列表比双端链表更节约内存， 并且在元素数量较少时， 在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中；

压缩列表类似于数组---”内存连续块“

### 8. 对象

#### -对象的类型与编码

##### 	类型：

对于 Redis 数据库保存的键值对来说， 键总是一个字符串对象， 而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种， 因此：

- 当我们称呼一个数据库键为“字符串键”时， 我们指的是“这个数据库键所对应的值为字符串对象”；
- 当我们称呼一个键为“列表键”时， 我们指的是“这个数据库键所对应的值为列表对象”，

诸如此类。

TYPE 命令的实现方式也与此类似， 当我们对一个数据库键执行 TYPE 命令时， 命令返回的结果为数据库键对应的值对象的类型， 而不是键对象的类型：

```
# 键为字符串对象，值为字符串对象

redis> SET msg "hello world"
OK

redis> TYPE msg
string
```

##### 	编码：

| 编码常量                    | 编码所对应的底层数据结构      |
| --------------------------- | ----------------------------- |
| `REDIS_ENCODING_INT`        | `long` 类型的整数             |
| `REDIS_ENCODING_EMBSTR`     | `embstr` 编码的简单动态字符串 |
| `REDIS_ENCODING_RAW`        | 简单动态字符串                |
| `REDIS_ENCODING_HT`         | 字典                          |
| `REDIS_ENCODING_LINKEDLIST` | 双端链表                      |
| `REDIS_ENCODING_ZIPLIST`    | 压缩列表                      |
| `REDIS_ENCODING_INTSET`     | 整数集合                      |
| `REDIS_ENCODING_SKIPLIST`   | 跳跃表和字典                  |

**每种类型的对象都至少使用了两种不同的编码， 表 8-4 列出了每种类型的对象可以使用的编码。**

| 类型           | 编码                        | 对象                                                 |
| :------------- | :-------------------------- | :--------------------------------------------------- |
| `REDIS_STRING` | `REDIS_ENCODING_INT`        | 使用整数值实现的字符串对象。                         |
| `REDIS_STRING` | `REDIS_ENCODING_EMBSTR`     | 使用 `embstr` 编码的简单动态字符串实现的字符串对象。 |
| `REDIS_STRING` | `REDIS_ENCODING_RAW`        | 使用简单动态字符串实现的字符串对象。                 |
| `REDIS_LIST`   | `REDIS_ENCODING_ZIPLIST`    | 使用压缩列表实现的列表对象。                         |
| `REDIS_LIST`   | `REDIS_ENCODING_LINKEDLIST` | 使用双端链表实现的列表对象。                         |
| `REDIS_HASH`   | `REDIS_ENCODING_ZIPLIST`    | 使用压缩列表实现的哈希对象。                         |
| `REDIS_HASH`   | `REDIS_ENCODING_HT`         | 使用字典实现的哈希对象。                             |
| `REDIS_SET`    | `REDIS_ENCODING_INTSET`     | 使用整数集合实现的集合对象。                         |
| `REDIS_SET`    | `REDIS_ENCODING_HT`         | 使用字典实现的集合对象。                             |
| `REDIS_ZSET`   | `REDIS_ENCODING_ZIPLIST`    | 使用压缩列表实现的有序集合对象。                     |
| `REDIS_ZSET`   | `REDIS_ENCODING_SKIPLIST`   | 使用跳跃表和字典实现的有序集合对象。                 |

```
redis> SET msg "hello wrold"
OK

redis> OBJECT ENCODING msg
"embstr"

redis> SET story "long long long long long long ago ..."
OK

redis> OBJECT ENCODING story
"raw"
```

#### -列表对象

列表的底层数据结构为zipList（压缩列表 ）或者LinkedList（双向不循环链表），当列表中元素数量小于等于512个，且所有元素的长度小于等于64字节时为zipList，任一条件不满足时转换为LinkedList。

#### -哈希对象

哈希表的底层数据结构为zipList（压缩列表 ）或者hashtable（字典表表），当列表中元素数量小于等于512个，且所有元素的长度小于等于64字节时为zipList，任一条件不满足时转换为LinkedList。

#### -集合对象

集合对象的编码可以是 `intset` （整数集合）或者 `hashtable`（key为字符串对象，value全部置为null） 。当集合对象可以同时满足以下两个条件时， 对象使用 `intset` 编码：1.集合对象保存的所有元素都是整数值；2.集合对象保存的元素数量不超过 `512` 个

#### -有序集合对象

有序集合的编码可以是 `ziplist` 或者 `skiplist` 。

#### -类型检查与命令多态

##### 	类型检查与多态命令：

String hash ：set get

set zset：add range rem

Redis 中用于操作键的命令基本上可以分为两种类型。

其中一种命令可以对任何类型的键执行， 比如说 DEL 命令、 EXPIRE 命令、 RENAME 命令、 TYPE 命令、 OBJECT 命令， 等等。

##### 	类型检查的实现：

为了确保只有指定类型的键可以执行某些特定的命令， 在执行一个类型特定的命令之前， Redis 会先检查输入键的类型是否正确， 然后再决定是否执行给定的命令。

借用面向对象方面的术语来说， 我们可以认为 LLEN 命令是多态（[polymorphism](http://en.wikipedia.org/wiki/Polymorphism_(computer_science))）的： 只要执行 LLEN 命令的是列表键， 那么无论值对象使用的是 `ziplist` 编码还是 `linkedlist` 编码， 命令都可以正常执行。

实际上， 我们可以将 DEL 、 EXPIRE 、 TYPE 等命令也称为多态命令， 因为无论输入的键是什么类型， 这些命令都可以正确地执行。DEL 、 EXPIRE 等命令和 LLEN 等命令的区别在于， 前者是基于类型的多态 —— 一个命令可以同时用于处理多种不同类型的键， 而后者是基于编码的多态 —— 一个命令可以同时用于处理多种不同编码。

#### -内存回收

C语言并不具备自动的内存回收功能，redis在自己的对象系统中构建了一个**引用计数**技术实现的内存回收机制

#### -对象共享

在 Redis 中， 让多个键共享同一个值对象需要执行以下两个步骤：1.将数据库键的值指针指向一个现有的值对象；2.将被共享的值对象的引用计数增一。

> 目前来说， Redis 会在初始化服务器时， 创建一万个字符串对象， 这些对象包含了从 `0` 到 `9999` 的所有整数值， 当服务器需要用到值为 `0` 到 `9999` 的字符串对象时， 服务器就会使用这些共享对象， 而不是新创建对象。

另外， 这些共享对象不单单只有字符串键可以使用， 那些在数据结构中嵌套了字符串对象的对象（`linkedlist` 编码的列表对象、 `hashtable` 编码的哈希对象、 `hashtable` 编码的集合对象、以及 `zset` 编码的有序集合对象）都可以使用这些共享对象。

#### -对象的空转时长

除了前面介绍过的 `type` 、 `encoding` 、 `ptr` 和 `refcount` 四个属性之外， `redisObject` 结构包含的最后一个属性为 `lru` 属性， 该属性记录了对象最后一次被命令程序访问的时间：

OBJECT IDLETIME 命令可以打印出给定键的空转时长， 这一空转时长就是通过将当前时间减去键的值对象的 `lru` 时间计算得出的：

除了前面介绍过的 `type` 、 `encoding` 、 `ptr` 和 `refcount` 四个属性之外， `redisObject` 结构包含的最后一个属性为 `lru` 属性， 该属性记录了对象最后一次被命令程序访问的时间：

#### -重点回顾

> - Redis 数据库中的每个键值对的键和值都是一个对象。
> - Redis 共有字符串、列表、哈希、集合、有序集合五种类型的对象， 每种类型的对象至少都有两种或以上的编码方式， 不同的编码可以在不同的使用场景上优化对象的使用效率。
> - 服务器在执行某些命令之前， 会先检查给定键的类型能否执行指定的命令， 而检查一个键的类型就是检查键的值对象的类型。
> - Redis 的对象系统带有引用计数实现的内存回收机制， 当一个对象不再被使用时， 该对象所占用的内存就会被自动释放。
> - Redis 会共享值为 `0` 到 `9999` 的字符串对象。
> - 对象会记录自己的最后一次被访问的时间， 这个时间可以用于计算对象的空转时间。

## 第二章 单机数据库的实现

### 9 数据库

#### -服务器中的数据

在初始化服务器时，程序会根据服务器状态的dbnum属性来决定应该创建多少个数据库，切换数据库实际上就是切换redisClient.db指针指向的位于数组上的服务器对象。

#### -数据库键空间

服务器中的每个数据库都由一个redisDb结构表示，其中redisDb结构的dict字典保存了数据库中的多有键值对，称这个字典为键空间。

![](images\数据库键空间.png)

##### Redis不保证原子性，如果在事务情况下一个命令在入队列时不报错但在执行时报错时，该命令不会生效，但是其他命令依然会生效，不符合原子性的定义：要么全部成功，要么全部失败。exec命令报错时，前面的命令依然会执行生效。

##### Redis没有隔离级别的概念，在队列中的命令没有被提交之前是不会被执行的，即在一个事务当中set一个值的之后再get这个值是get不到的，必须在提交之后该命令执行了来才能get到。

##### Redis也没有回滚机制。

