> count(1) == count(*)
>
> DDL:create drop alter
>
> DML:insert delete
>
> DQL:select shere
>
> DCL:grant

写法顺序：select--->from --->where --->group by --->having --->order by

执行顺序：from---> where --->group by --->having---> select---> order by

**where字段后面不能跟聚合函数！**

**要使用聚合函数就要配合group by使用，having字段必须和group by语句一起使用，group by的作用是限定分组条件，而having则是对group by中分出来的组进行条件筛选。**

group by易错知识点：

1. 使用group by子句中，**select子句不能出现聚合键之外的列名**。总结就是select子句中只能存在下面三种元素：
    - 常数
    - 汇总函数（聚合函数）
    - group by子句中指定的列名（聚合键）
2. group by子句不能使用select子句中定义的别名， 是因为sql先执行的group by，再执行select。
3. group by子句的结果是无序的。

- **having子句和select语句一样只能存在上面三种元素**
- 聚合键所对应的条件建议写在where子句中，而不是having子句中，可以提高运算速度，他们两者的作用区别可以理解为：
    - where子句=指定行所对应的条件
    - having子句=指定组所对应的条件

注意：在order by子句中可以使用聚合函数或者select子句中未使用的列

> case when
>
> then 1
>
> else 2

候选索引与主键索引一样需要字段的唯一性。

### 子查询：

> 子查询就是将用来定义视图的select语句直接用于from子句当中，还可以放在where子句中与in，all，any配合使用，简单一点说就是把一个查询的结果在另一个查询中使用就叫子查询。

- **子查询不会想视图那样保存在硬盘中，而是在select语句执行之后就消失了，因此子查询就是一张一次性的视图。**
- **在sql运行顺序中会先执行子查询，然后再执行外部语句。**
- **where x in （select x）**

子查询注意事项：

- 避免使用多层嵌套子查询，不容易看懂，也容易弄错。
- 子查询最好重新命名子查询名称（子查询 AS 子查询名称） 便于理解该子查询的用途和目的，类似于编程中变量命名。

#### 标量子查询：

> 标量子查询是指子查询返回的是单一值（一个数字或一个字符串）的标量，也是子查询中最简单的返回形式。

选取大于平均成绩学生的学号和成绩，错误写法：

```sql
select 学号，成绩 from score where 成绩 > AVG（成绩）;
```

**这样的写法程序会报错，因为where子句后面不允许使用聚合函数**，正确写法：

```sql
select 学号，成绩 from score where 成绩 > (select AVG(成绩) from score);
```

#### 关联子查询：

> 对于外部查询返回的每一行数据，内部查询都要执行一次，在关联子查询中信息流是双向的。外部查询的每行数据传递一个值给子查询，然后子查询为每一行数据执行一次并返回它的纪录。然后外部查询根据子查询返回的记录做出决策。

**在每个组里面比较一般会用到关联子查询：**查找出每个课程成绩都大于该课程平均成绩的学生。

```sql
select 学号，成绩，课程号 from score as s1 --同一个表要使用别名，便于区分 where 成绩 > (select AVG(成绩) from score as s2 --同一个表要使用别名，便于区分 where s1.课程号 = s2.课程号 group by 课程号 ) 
```

注意：关联条件一定要写在子查询中，且s2仅在子查询里面有效！

### 多表查询：

##### 设计多表时要考虑表与表之间的关系：

- 一对一

    - 外键

    - 共同主键

- 一对多

    - 在多的表中建立一的表的主键所对应的外键。

- 多对多

    - 建立中间表存储两个多表主键所对应的外键。

##### union：将两个表的数据按照行合并在一起，并且重复值只保留一个

```sql
select 课程号，课程名称 from course union select 课程号，课程名称 from course1
```

如果想保留重复值，那么就使用union all，*需要注意的是，这里的重复是指两张表中课程号和课程名称完全相同的行，其他列是否重复不影响查询结果。即重复值只针对select子句中查询的字段*。

##### 内联结(inner join)：查找出同时存在于两张表的数据。两张表中满足于关联条件的所有数据都查找出来。

```sql
select a.学号,a.姓名,b.课程号 from student as a inner join score as b on a.学号 = b.学号;
```

![内联结](D:\images\内联结.png)

#### 左联结(left join)：

> 取出左边表的全部数据，右边的表选出与左边相同数据的行，然后进行数据合并。

```sql
select a.学号，a.姓名,b.课程号 from student as a left join score as b on a.学号 = b.学号;
```

![左联结示意图](D:\images\左联结示意图.png)

**如果想查找在左表中有而在右表中没有的数据**：只需限定右表关联条件为空即可。

![左表相对右表没有的](D:\images\左表相对右表没有的.png)

```sql
select a.学号，a.姓名,b.课程号 from student as a left join score as b on a.学号 = b.学号 where b.学号 = null;
```

**当有多个外连接的时候，会按照从左向右的顺序执行sql语句，即先用A表连接B表，生成一张临时中间表再和C表进行连接。**

#### 全联结(full join):

> 取出左表和右表的所有数据，有相同数据就合并，没有则用null来填充。

**mqsql不支持全联结。**

### case：条件函数

![case应用](D:\images\case应用.png)

![case应用2](D:\images\case应用2.png)

### **通过explain语句可以分析，mysql是如何执行这条sql语句的。**

### 索引：

- 主键索引：非空且唯一
- 唯一索引：非空
- 全文索引
- 普通索引

1. 一般来说创建表的时候都会指定主键索引，如果创建表时没有指定主键索引，也可以在创建表后再添加：

```sql
alter table user add primary key (列名);
```

2. 一般来说，普通索引的创建，是先创建表，然后再创建普通索引：

```sql
create index 索引名 on 表 (列1，列2);
```

3. 全文索引，不经常用，全文搜索常用elasticsearch实现。
4. 唯一索引，unique字段可以为null，但是如果是具体内容，则不能重复

```sql
create unique index 索引名 on 表 （列1，列2);
```

5. 删除索引：

```sql
alter table 表名 drop index 索引名;
```

#### SQL语句的小技巧：

1. 在使用group by分组查询时，分组后会默认排序，可能会降低速度，在group by后面增加order by null就可以防止排序。

2. 有些情况下可以用连接来代替子查询。因为使用join，mysql不需要再内存中创建临时表。

   ```sql
   select * from dept, emp where dept.deptno = emp.deptno;[简单处理]
   select * from dept left join emp on dept.deptno = emp.deptno;[连接更ok]
   ```



**<selectKey>：insert的时候当插入表id为自增时需要用到selectkey查找last_insert_id**

**MySQL的唯一联合索引中若是有一个或以上字段为null时，该索引的唯一性将失效**

关于insert ignore into:忽略仅仅是忽略主键或者索引重复的数据，如果主键或者索引没有重复，即使其他数据重复了也依然能够插入数据。**问题出在如果主键是自增的话，插入数据的时候主键已经自增一了，则主键永远不可能重复，就永远达不到忽略重复数据的效果。解决办法：把想要保证不重复的字段也加上索引**。  发生场景：表中仅有id为主键，当其他字段插入重复数据的时候也能插入成功。除非把想要不重复的字段加上联合唯一索引。

特别说明：在MYSQL中UNIQUE索引将会对null字段失效，也就是说(a字段上建立唯一索引)：

```
 INSERT INTO `test` (`a`) VALUES (NULL);1
```

是可以重复插入的（联合唯一索引也一样）。

#### can't update when select:

**无法在查询一张表的时候对一张表进行更改。如果想要达到效果可以把查出来的结果封装成一个中间表：**

```sql
delete from schema.table where t.parent_id in (select temp.id from (select id from schema.table where sex = 'man') temp);
```

**1.INSERT INTO SELECT****语句**

语句形式为：

```sql
Inser into Table2(field1,field2,…) select value1,value2,… from Table1
或者：
Insert into Table2 select *  from Table1
```

注意：（1）要求目标表Table2必须存在，并且字段field,field2…也必须存在

（2）注意Table2的主键约束，如果Table2有主键而且不为空，则 field1， field2…中必须包括主键

（3）注意语法，不要加values，和插入一条数据的sql混了，不要写成:

Insert into Table2(field1,field2,…) values (select value1,value2,… from Table1)

由于目标表Table2已经存在，所以我们除了插入源表Table1的字段外，还可以插入常量

**2.SELECT INTO FROM****语句**

语句形式为：

```sql  
SELECT vale1, value2 into Table2 from Table1
```

要求目标表Table2不存在，因为在插入时会自动创建表Table2，并将Table1中指定字段数据复制到Table2中。

### MySQL主从复制

![](D:\images\主从复制.png)

binlog(binary log)即二进制日志文件，记录了数据库中所有的ddl和dml SQL语句

主从复制过程：

1. 主库将数据库中变化的数据写入到binlog。
2. 从库连接主库。
3. 从库创建一个I/O线程请求主库的binlog。
4. 主库创建一个binlog dump线程发送binlog，从库的I/O线程负责接收。
5. 从库的I/O线程将接受的binlog写入到relay log中。
6. 从库的SQL线程负责读取relaylog中的数据同步到本地。



### MySQL分库分表

如果MySQL的一张表的数据量过大就得分库分表。

分库：将数据库中的数据分布到不同的数据库节点上。

- 用户表和用户订单表分布在两个不同的数据库节点上。
- 由于用户表数据量过大，将用户表进行切分成两张表，两张表放到不同的数据库上。

分表：

- 水平切分：将一张行比较多的表水平切割成多张表。
- 垂直切分:   把一张列比较多的表垂直切分成多张表。

![](D:\images\分库分表.jpg)

引入分库分表带来的挑战：

- **join操作**：同一张表的数据分布到了不同的数据库中导致无法使用join命令，需要手动封装，在A库查到数据后手动联结到B库的数据。
- **事务问题**：如果单个操作涉及到多个数据库的数据，数据库自带的事务无法再提供保障，考虑分布式事务。
- **分布式id**：引入分布式id生成全局唯一递增的业务id。

### Mysql第一讲

MySQLserver层：连接器->查询缓存(mysql8.0后取消，因更新频繁会导致缓存频繁失效)->分析器->优化器->执行器。所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等，

MySQL存储引擎层：负责数据的存储和提取

### MySQL第二讲

#### redo log：

当有一条记录需要更新时，innodb会将记录写到redo log中并更新内存，这个时候更新就算是完成了。同时innodb会在系统比较空闲的时候将记录写到磁盘中。

redo log的大小是固定的，如果redo log中的记录写满了还没有更新到磁盘中时，这个时候不能再执行新的更新，需要先把一部分记录写到磁盘中。

redo log的两个指针：checkpoint、 write pos，write pos表示当前记录的位置，checkpoint表示当前需要擦除的记录的位置，write pos和checkpoint之间的距离表示redo log还可以写的记录大小。

**有了redo log，innodb可以保证即使数据库发生重启之前提交的记录都不会丢失。这个被称为crash-safe能力。redo log是indodb特有的日志。**

#### binlog：

binlog（归档日志）是server层特有的日志。

为什么有两份日志？

> 最开始MySQL没有innodb引擎，自带的myisam引擎没有crash-safe能力，binlog日志只能用于归档。后来引入innodb引擎提供crash-safe能力。

##### 两份日志的区别：

1. redo log是innodb特有的，binlog是mysql的server层提供的，所有引擎都可以使用。
2. redo log是物理日志，记录的是“在某个数据页上做了什么“；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如”给id=2这一行的c字段加1“，类似于redis的aof日志。
3. rodo log是循环写的，空间固定会用完；binlog是追加写入的，当前文件写完后会切换到下一个，并不会覆盖以前的日志。

### MySQL第三讲：事务的隔离级别

##### 事务的实现

在实现上，数据库会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复度”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个sql语句执行的时候创建的，即在“读提交”隔离级别下，整个事务期间执行了多少条sql就会有多少个视图；在“读未提交”隔离级别下，直接返回记录上的最新值，没有视图概念；在串行化隔离级别下直接用加锁的方式避免并发访问。

##### 事务隔离的实现

在MySQL中，实际上每条记录的更新都会同时记录一条回滚操作，记录上的最新值通过回滚操作都可以得到前一个状态的值。不同时刻启动的事务会有不同的read-view，同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）。同时会发现如果这个时候有另外一个事务将记录修改成其他值，这个事务也不会跟当前read-view所对应的事务也不会冲突。

回滚日志什么时候删除呢？答案是在不需要的时候删除，即系统会判断当没有事务再需要会用到这些回滚日志时就会将这些日志删除掉。什么时候不需要呢？当系统里没有比这个回滚日志更早的read-view的时候。

##### 尽量避免用长事务

长事务会意味着系统里面存在很老的事务视图，在”读已提交“隔离级别下在事务提交之前，长事务会创建出很多视图，这些视图会占用大量的存储空间。在MySQL5.5以前回滚日志是不会被清除的。

### MySQL第四讲：索引

#### 索引的常见模型

##### 哈希表

哈希表的内部结构是数组加链表的形式，由于key是通过hash算法存储到数组桶中的，不太规律，当需要做范围查询的时候就需要把整个数组都扫描一遍。因此哈希表只适合做等值查询，类似于memcached及其他一些nosql引擎，不适合做范围查询。

##### 有序数组

有序数组不论是做等值查询还是范围查询效率都很高，但是要插入数据时需要把大于该值的数据往后挪，插入效率会很慢。因此有效数组只适合做只查询不插入的场景。

##### 二叉搜索树

二叉搜索树查询效率为O(log(N))，同时为了维持二叉树的平衡，插入的效率也是O(log(N))。二叉树的问题是当数据量大时树会很高，查询一行数据时会访问很多数据块（多次磁盘IO），效率低下，因此使用多叉树使树高尽量的减小。

#### Innodb

根据叶子节点的内容，索引类型分为主键索引和非主键索引。主键索引的叶子节点存放的是整行数据，非主键节点的叶子节点的内容存放的是主键的值。在innodb里，主键索引被称为聚簇索引，非主键索引被称为二级索引。

如果根据非主键索引进行查询的话，需要先到非主键索引的树找到该行数据对应的主键值，再根据主键值去主键索引的树查找数据，这一过程称为回表。

B+树为了维护索引的有序性，在插入新值的时候需要做必要的维护。如果新插入的值是最大的只需要在后面插入一个新纪录，但如果不是最大的就需要挪动比新值大的数据（例如R5数据页）到后面去，空出位置。更糟糕的情况是如果R5所在的数据页已经满了，根据B+树的算法，需要申请一个新的数据页然后挪动R5部分数据过去，这个过程成为页分裂。

除了性能外，页分裂操作还会影响数据页的利用率，原本放在R5一个数据页的数据，现在分到了两个数据页当中，整体空间利用率下降了50%。当然有页分裂就有页合并，当相邻两个页删除了数据利用率很低之后，会将数据页做合并。

自增主键保证了每一次插入都是追加操作，不涉及到其他记录，也不会触发数据页的分裂。普通索引的记录插入则会触发页分裂。**主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。**

#### 为什么要重建索引？

索引可能因为删除或者页分裂等原因导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。

#### 有没有什么场景适合直接用业务字段直接做主键？

1.只有一个索引；2.该索引必须是唯一索引。

满足这种场景的就是典型的KV场景，由于没有普通索引，就不用考虑普通索引叶子节点大小的问题。

#### 覆盖索引

select ID from T where k between 3 and 5;

这个时候只需要查id值，而id值就在k索引树的叶子节点上，不需要回表。也就是说在这个查询中索引k已经”覆盖了“我们的查询请求，我们称为覆盖索引。

**由于覆盖索引可以减少树的搜素次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。**

只需要查询联合索引中的字段时也利用了覆盖索引，例如index X(a,b),select a from T where a = '1' and b = '2';a字段存在于联合索引X当中，这样走X树时就能查询到a，不需要再次回表。

#### 最左匹配原则

不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索，**最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符(like abc%)。**

#### 在建立联合索引的时候，如果安排索引内的字段顺序？

**第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。**

#### 索引下推优化

可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

检索出"名字第一个字是张，而且年龄是10岁的所有男孩"

select * from tuser where name like "张%" and age = 10 and ismale = 1;

index(name，age);

在检索出所有张姓男孩之后，在遍历索引时就会过滤掉所有age不等于10的记录，在回表的时候直接查询ismale=1的记录。

![](D:\images\索引下推优化.png)

### MySQL第五讲 锁

#### 全局锁

对整个数据库实例加锁，MySQL提供了一个flush tables with read lock(FTWRL)命令让整个数据库处于只读状态,之后其他线程的以下语句会被阻塞：数据的增删改，表结构的修改。

全局锁的典型使用场景是，做全库逻辑备份。

#### 表级锁

表级锁分为表锁和元数据锁(Mata data lock, MDL)

##### 表锁

表锁的语法是：lock tabls --- read/write。与FTWRL类似，可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。

如果在某个A线程中执行lock table t1 read, t2 write;**其他线程写t1,读写t2的语句都会被阻塞**。同时线程A在执行unlock tables之前，**也只能执行读t1、读写t2的操作**。连写t1都不允许，自然也不能访问其他表。

##### MDL

另一类表级的锁是MDL。MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是保证读写的正确性。

当对一个表做增删改查操作的时候，加MDL读锁；当对表对表结构变更的时候，加MDL写锁。

- 读锁之间不互斥，即多个线程可以同时一张表进行增删改查。
- 读写锁、写锁之间是互斥的，即同时只能有一个线程对表结构做变更。这么做用来保证表结构操作的安全性。

**MDL锁不是在执行完sql后释放，而是在事务提交之后才释放。**

#### 行锁

行锁是在引擎层由各个引擎自己实现的。myisam引擎不支持行级锁，innodb支持行级锁。

**在innodb事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。**

行级锁容易造成死锁的发生。

出现死锁之后有两种策略：

1. 直接进入等待，直到超时，超时之后会有一个线程释放锁。缺点：超时时间太长会让其他线程等待时间太长；超时时间太短容易造成误伤（不是死锁，只是简单的锁等待）。
2. 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务。

### MySQL第六讲 事务隔离

#### MVCC快照工作原理

在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。这个快照是基于整库的。

innodb里面每个事务都有一个唯一的事务id，叫做transaction id，它是在事务开始的时候向innodb的事务系统申请的，是按申请顺序严格递增的。

而每行数据都有多个版本，每次事务更新数据的时候都会生成的一个新的数据版本，并把transaction id赋值给这个数据版本的事务id，记作row trx_id。同时旧的数据版本也要保留，并且在新的数据版本中能够拿到旧的数据版本。

即数据表中的一行记录会有多个数据版本，且每个数据版本都有自己的row trx_id。

事务的回滚是通过读取undo log进行回滚的。

可重复读的定义这个事务执行期间，其他事务的更新对它不可见，因此一个事务只需要在启动的时候声明说:"以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是在我启动之后生成的，我就不认，我必须找到它的上一个数据版本“。**如果是该事务自己更新的数据，它自己还是要认的。**

一个事务的启动瞬间会维护一个活跃（启动了还未提交）事务的数组，数组中trx_id最小的称为低水位，最大+1的称为高水位。低水位之前的是已提交了的事务，对于当前事务是可见的；高水位之后的是还未启动的事务，对于该事务是不可见的。

如果有一个事务的低水位是18，V4版本的trx_id是25，则会通过U4的undo log回滚到trx_id为17的V3版本，则该事务对于该行数据的值就是V3版本的。

**更新数据都是先读后写的，而这个读，只能读当前的值，称为”当前读“。哪怕当前值是由高水位之后的事务进行更新的。也要读到再在新值的基础上进行更新，不然高水位之后的事务更新就失败了。**

普通查询语句是一致性读，一致性读会根据row trx_id和一致性视图确定数据版本的可见性：

- 对于可重复读，查询只承认在事务启动前就已经提交完成的数据。
- 对于读提交，查询只承认在语句启动之前就已经提交完成的数据。
- 对于当前读，总是读取已经提交完成的最新版本。

### MySQL第七讲 唯一索引和普通索引

innodb的数据是按数据页为单位进行读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在innodb中每张数据页的默认大小为16kb。

对于查询，唯一索引和普通索引的性能差距是微乎其微的；对于更新，由于change buffer机制，普通索引的更新并不会立即把数据页读入内存进行更新，而是写进change buffer等待下一次查询该数据页时进行合并更新（适合写多读少情景）；而唯一索引由于需要判断唯一性所以每一次更新时都需要把目标数据页读入内存进行计算判断唯一性，性能会受到影响。

所以，如果对唯一性没有特别要求的话，优先使用普通索引，普通索引配合change buffer的机制在读少写多的情景下收益是非常显著的。

#### change buffer和redo log的区别

执行一条sql语句，insert into t (id,k) values (1,k1),(2,k2);

假设k1数据页page1在内存中，k2数据页page2没有在内存中。更新逻辑如下：

1. page1在内存中，直接更新内存。
2. page2没有在内存中，就在内存的change buffer区域记录往page2插入一行的记录。
3. 将上述两个动作计入redo log。

执行该次操作涉及两次内存的操作和一次硬盘的操作（顺序写）。

如果此时再读数据的话：

1. 读page1的话，直接从内存返回。
2. 读page2的话，将数据页加载进内存之后应用change buffer中与该页有关的操作，更新记录之后再返回结果。

比较：**redo log主要节省的是随机写磁盘的IO消耗（转成顺序写），而change buffer主要节省的是随机读磁盘的IO消耗。**

思考题：![](D:\images\数据无法修改.png)



SessionA修改没有起作用的原因：SessionB对数据提前做了修改，SessionA在修改的时候会先读（当前读）后写，当前读的数据是SessionB修改之后的数据，所以之后的修改没有作用到任何行的数据；接下来SessionA的查询是查不到SessionB所带来的影响的，因为SessionB是在高水位之后，对SessionA不可见，所以SessionA还是只能查询到低水位的情况。

### MySQL第八讲 选错索引

当MySQL优化器在选择用什么索引执行sql语句的时候会综合各种情况选择自认为效率最高的索引，但有些时候反而会选错索引导致执行速度变慢，这个时候可以强制MySQL使用指定索引，select * from t force index(indexName) where ......,但是强制索引有些时候不是最好的选择，随着业务的更改或者数据库的迁移维护起来太过麻烦！