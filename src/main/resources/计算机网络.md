##### 子网掩码：

+ 子网掩码的作用：用来划分一个ip地址的网络地址和主机地址，两个ip地址的<u>*网络地址*</u>（*<u>掩码对应的位数）</u>*一样的话那么就能说明他们是同一个网段。
+ 求一个ip地址的网络地址：将ip地址与他的子网掩码相与AND。
+ 子网掩码的前面为1的就是网络地址，后面为0的就是主机地址。

> 11111111 11111111 11111100 00000000  该子网掩码就是255.255.252.0，为C类地址。ip地址的前三个字节相与出来一样就在同一个网段。

**192.168.0.1/22已经说明了该IP地址的子网掩码前22位为网络地址**

##### 多播/组播：

+ 单播：一对一，单对单

+ 广播：一对多，该网段内的所有主机都能收到消息

+ 多播：一对多，一个发送者把数据包发到一个组地址，主机只需要加入这个组就可以收到这些数据包s

    + 缺点：

        + 采用udp协议

    + 优点：

        + 节省网络带宽
        + 节省网络设备性能
        + 适合分布式应用

    + 多播地址为D类地址，D类地址前四位为1110，没有掩码

    + | 网络 | 高八位 | 掩码     |
          | ---- | ------ | -------- |
      | A类  |        | 八位     |
      | B类  |        | 十六位   |
      | C类  |        | 二十四位 |
      | D类  |        | 组播     |
      | E类  |        | 保留     |

    + IGMP协议：用来管理一个组里的ip地址

###### 二层：

即一个网段

###### 三层：

不同的二层桥接起来，两个不是同一网段的网络如果要进行通信需要进行三层的转化

###### 路由：

路由就是必由之路的意思，在网络里面就是指导设备去不同子网的路应该怎么走。

###### 网关：

1. 通俗讲，就是一道门，当需要从二门出去到三门的时候就需要走网关，即从一个网段去往另一个网段需要走网关。
2. 什么情况下需要路由：
    + 当被访问的地址跟本地的地址不在一个子网内，就需要本地有去往目标地址网段的路由。
    + default是默认路由，也就是0.0.0.0./0的路由

##### MAC地址：

网卡的唯一标识，点对点传输就是MAC地址

##### ARP协议：

通俗讲，就是一座用来沟通ip和mac地址的桥梁。当你配置一个ip地址开始就会发送查询自己ip的arp来检查是否有ip地址冲突。

###### ARP的作用：

两个主机要是在同一网段内直接用mac地址进行通信，arp直接在网段内广播哪个mac地址有该ip地址，单播回来给我。通过arp就能获得mac地址。

##### VLAN：

通俗讲，VALN就是把一个大的LAN虚拟成很多的虚拟LAN，即将一个大的子网划分为多个隔离的小子网，好处是把广播域调小。一个子网对应一个VLAN。

##### 测试工具

1. ping
2. tracert/traceroute:可以用来检查点到点之间的节点路径，通常用来检查路由节点或者在点到点不通的情况下排查问题点位置。
3. telnet/curl：可以用来检查目标主机的端口是否可达，一般用来简易验证服务是否开启。

### Cookie、Session、Token

> HTTP是无状态协议，每次登录一个网站的时候网站都不知道该用户是谁需要重新认证。使用token等手段可以每次访问该网站的时候都让网站知道用户是谁并自动登录。

##### cookie:

> cookie是一个非常具体的东西，指的是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。

cookie由服务器生成，发送给浏览器，浏览器将cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。cookie不会占用太多磁盘空间。

##### session：

> 服务器要知道当前发请求给自己的是谁，要给每个客户端分配不同的“身份标识”，然后客户端每次向服务器发起请求的时候都带上这个身份标识。

客户端保存身份标识用cookie的方式，服务器使用**session把用户的信息临时保存在服务器上**，**用户离开网站后session会被销毁**，这种用户信息存储方式相对cookie来说更安全，因为把认证信息放在了服务器上，可是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。

##### token：

session的缺陷：

- 每次认证用户发起请求时，服务器需要创建一个记录来存储信息。当越来越多的用户发请求时，内存的开销也会不断增加。
- session的可扩展问题。

> 基于 token的身份验证是无状态的，不将用户信息放在服务器或者session中。

基于token的身份验证过程：

1. 用户通过用户名和密码发请求。
2. 程序验证用户名密码。
3. 程序返回一个签名的token给客户端。
4. 客户端存储token，并且用于每次发送请求。
5. 服务器验证token并返回数据。

- **每一次请求都需要token，token应该在http的头部发送保证http请求无状态。**
- **即便在客户端使用cookie存储token，cookie也仅仅是一个存储机制而不是用于认证。**
- token是有时效性的，一段时间后用户需要重新认证。

##### token refresh_token:

1. token没过期，验证通过
2. token过期了，但refresh_token没过期，则刷新新的token和refresh_token，将请求内容以及access token返回给用户。
3. token和refresh token 都过期，验证失败。

> 通常token时间都很短，且越短越好，refresh token因为没有保存过多的业务信息，只保存了token的过期时间等，所以理应加长一点，一般为token的一倍时长。

在用户访问期间，如果token过期了，但客户仍处于活跃状态时，应该由refresh token刷新token时间以期继续使用。